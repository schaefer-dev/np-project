\documentclass[12pt]{article} 
\usepackage{german} 
\usepackage[utf8]{inputenc} 
\usepackage{latexsym} 
\usepackage{tabu}
\usepackage{amsfonts} 
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{enumerate}
\usepackage{MnSymbol}
\usepackage[colorlinks=true,urlcolor=blue]{hyperref}
\usepackage{listings}
\usepackage{graphicx}
\pagestyle{plain}

% Formatierung
\topmargin -2cm 
\textheight 24cm
\textwidth 16.0 cm 
\oddsidemargin -0.1cm

\setlength{\parindent}{0pt}  % !!!!!!! Hier werden leerzeilen erlaubt ohne dass Latex automatisch einrueckt! !!!!!!! %

% Code-Highlighting 
\lstset{language=Java, breaklines=true, showstringspaces=false}
%\begin{lstlisting}
%    	Hier w체rde der Java-Code hinkommen und entsprechend die Syntax markiert. Selbst einr체cken.
%\end{lstlisting}
%ODER:
% \lstinputlisting[language=Java]{name.java}

\begin{document}

% Titel
%\title{\textsc{Hacking}\\ \textsc{Abgabe 0}\\{ \normalsize Gruppe X \hfill Daniel Sch채fer (2549458)\\ \hfill Anderer}}
%\maketitle  

% alternativer Titel
\noindent
{\Large \textbf{Nebenlaeufige Programmierung}} \hfill Daniel Sch채fer (2549458) \\
{\Large \textbf{Meilenstein 1}} \hfill Christian Bohnenberger (2548364)
\\
{\textbf{16.07.2015}}
\\

\section{Einfuehrung}

Nach anschauen des Codes ist uns klar geworden, dass es auf jeden Fall wichtig sein wird die Rate fuer jeden ''Node'' zu speichern um das staendige Iterieren ueber guards in getRateForTarget zu vermeiden.\\
Wir werden eine Node Klasse anlegen, die einen einzelnen Punkt implementiert. Dieser kennt seine x und y Koordinate als int, als auch seine Rate in die Richtungen oben, rechts, unten und links. Ebenfalls wichtig wird der double-Wert value, der den momentanen Wert des Knotens enthaelt. Ausserdem einen Akku fuer den Knoten links, rechts, oben und unten. Hier speichern wir Uebertraege in die entsprechenden Richtungen. Die ganze Klasse Node wird als Monitor implementiert um Data Races zu vermeiden. \\
Eine komplette Spalte betrachten wir als Thread und in der Berechnung eines Iterationsschrittes des Osmozeprozesses werden wir zuerst fuer jeden Thread, also jede Spalte die Akkumulatoren nach oben, unten, rechts und links anhand der gespeicherten Rates berechnen. Dies wird ueber einen iterativen Funktionsaufruf, der nacheinander die calculate() Funktion auf den Knoten der Spalte aufruft, uebernommen. Anschliessend rufen wir auf jedem Knoten die Funktion flow() auf. Diese fasst die Akkumulatoren nach links und rechts NICHT an, uebertragt jedoch die Uebertraege nach oben und unten in die entsprechenden Knoten obendrueber bzw. untendrunter und addiert die Akkumulatoren auf deren momentanen Wert. Wir benoetigen nur fuer die Funktion communicate() spaeter syncronized da nur hier verschiedene Threads kommunizieren. Die Funktion wird nach x Iterationsschritten (x ist vom Benutzer setzbar und bestimmt die Genauigkeit unserer Berechnung) aufgerufen und sorgt dafuer dass die Uebertraege nach links und rechts ueber die Spalten hinaus an die korrespondierenden Nachbarn verteilt werden. Es wird also eine Barrier geben die nach x Schritten die Iteration unserer calculate() und flow() Funktion fuer jeden Thread anhaelt um einen korrekten Aufruf von communicate() zu ermoeglichen.\\
Zu den Datentypen: Die Spalten werden wir als ArrayListe von Nodes implementieren um Zugriffe mit einem Getter auf bestimmte Positionen als auch angenehmes Iterieren zu ermoeglichen.\\
Ebenfalls sehr relevant zum Sparen von Speicher ist die Tatsache, dass wir zu Beginn nur die Knoten erzeugen die tatsaechlich eine Value > 0 enthalten. Beim Erzeugen von Knoten werden alle ihre Werte (also auch die Rate nach oben, unten usw.) berechnet. Wir haben uns fuer den Moment gegen das Loeschen von Knoten entschieden die ihre Value 'nullen', da wir vermeiden wollen Knoten staendig erneut erzeugen zu muessen, da dies doch relativ aufwendig ist aufgrund der Iteration ueber Guards um die Rates zu speichern. Wir werden hier ggf. Anpassungen nach Fertigstellung unseres Projektes vornehmen abhaenig davon, wie sich die Laufzeit verhaellt. Zum Ersparen zusaetzlicher Laufzeit ist es wichtig, dass wir bei der Funktion communicate() ZUERST ueberpruefen ob ueberhaupt ein Uebertrag in Knoten (x,y) existiert bevor wir auf dessen Existenz ueberpruefen, da wir ihn nur erzeugen moechten (angenommen er waere noch nicht erzeugt) falls ein Akkumulator auf seinen Wert addiert werden wuerde.\\
Unsere Barrier implementieren wir in der Klasse Column die Runnable implementiert, mit einer Bedingung in der run() Funktion, in der etwas wie \verb+while (count%x != 0)+ uberprueft wird. Jede Column enthaellt den int count der die Nummer des momentanen Durchlaufs enthaelt, als auch die Arrayliste mit den Nodes dieser Spalte. Ebenfalls enthalten sind die Columns left und right als Referenzen auf diese Spalten um nachher den Datenaustausch von commmunicate() einfacher zu realisieren. Die Spalten rufen also communicate() auf allen Knoten ihrer Spalte auf. Communicate() enthaelt in den Argumenten Referenzen auf die Nodes mit denen dieser Node 'communicated', also seine linken und rechten Nachbarn. Ebenfalls klar ist, dass man hier auf null-Faelle an Raendern und noch nicht existierenden Nodes achten muss (wichtig natuerlich Unterscheidung zwischen Rand und noch nicht erzeugtem Node!). Die einzelnen Spalten sind in der Klasse Picture enthalten, die das komplette Osmosebild repraesentiert. Das Bild wird unter anderem die Spalten in entsprechender (maximal)Groesse erstellen und anschliessend die Referenzen der Nachbarspalten fuer jede Spalte setzen.\\
Wir betrachten bei Aufruf von communicate() ebenfalls Spaltenkonvergenz indem wir die Summe der Akkumulatoren die 'nach links gehen' in einer Spalte addieren und schauen wie viel in der Spalte links daneben 'nach rechts geht'. Wir ueberpruefen also ob Inflow einer Spalte $\approx$ Outflow der Spalte. Bei einer Differenz $< \epsilon$ erkennen wir lokale Spaltenkonvergenz. Tritt in allen Spalten lokale Spaltenkonvergenz auf sprechen wir von globaler Spaltenkonvergenz. Diese muessen wir erkennen, da wir nach Erkennen globaler Spaltenkonvergenz einen genaueren Test der auch die Reihen ueberwacht starten. \\
Die linke Spalte hat einen gesetzten boolean mastercolumn = true, dieser sorgt dafuer, dass diese Spalte den ''Terminierungstest'' initialisiert. Die Masterspalte ruft rekursiv checkTerminate() auf ihrer rechten Nachbarspalte auf sofern ihr eigenes checkTerminate true war. Dies wird rekursiv fortgesetzt bis eine Spalte false returnt. In diesem Fall wird dann regulaer fortgesetzt und communicate() aufgerufen. Falls jede Spalte true returnt und man in der letzten Spalte ankommt ruft die Masterspalte startPreciseTest() auf und verringert die Barrier um einen Wert den wir uns noch ueberlegen. StartPreciseTest() setzt den boolean PreciseTest in jeder Spalte auf true. Wenn dieser boolean gesetzt ist veraendert jeder Thread sein Verhalten: Es wird nach wie vor nach Barrier Schritten communicated. Vor diesem communicate wird aber nicht nur checkTerminate() auf den Spalten aufgerufen, es wird zudem nach dem communicate fuer jeden Node die momentane value des Nodes in value\_old gespeichert. Sollte value\_old schon gesetzt sein wird vor dem neu setzen verglichen ob $value-value\_old < \epsilon/rows$. Falls das fuer jeden Node gilt rufen wir terminateThreats() in Picture auf. Die Ueberpruefung findet immer nach Erreichen eines Barrier-schrittes statt, wie bereits erwaehnt.\\
Wichtig ist zu erwaehnen das jede Spalte fuer sich nebenlaeufig rechnet, innerhalb einer Spalte calculate() und flow() jedoch sequentiell berechnet werden. Fuer eine bessere Skalierbarkeit unserer Implementierung halten wir uns die Moeglichkeit offen mehrere Threads auch pro Spalte zu ermoeglichen. Deshalb haben wir uns dafuer entschieden auch changeValue fuer Nodes synchronized zu implementieren.\\\\

Anbei fuegen wir noch ein kleines Klassendiagram an, das wir fuer uns selbst entworfen haben um uebersichtlich zu sehen welche Methoden wir in welcher Klasse implementieren wollten.

Korrektur:\\
Wir verwenden die Klasse Cyclic barrier. Diese wird mit der Anzahl an threads initialisiert und befindet sich in Picture. Der Klasse wird zudem ein Runnable uebergeben dass das communicate auf den threats in seiner run methode steuert, da cyclic barrier ermoeglicht eine zusatzliche run methode nach erreichen der barrier zu setzen. Vor dem Durchfuehren der communicate aktion ist die Barrier ebenso dafuer zusataendig in jedem Threat zu testen ob inflow = outflow. Falls dies true sein sollte.\\


genaue abfolge bei anlauf der barrier:\\
1. Moeglichkeit: Barrier das allererste mal angelaufen wird
\begin{itemize}
	\item Wir testen fuer jede Spalte ob inflow = outflow
	\item wir rufen startCommunicate auf den spalten auf, diese communicaten dabei ihre akkumulatoren auf die linken und rechten nachbarnodes (die akkumulatoren werden nach uebertragen natuerlich an dieser stelle genullt). Es ist an dieser stelle wichtig dass startCommunicate und communicte auf den nodes NICHT syncronized ist. Lediglich der changevalue() part der der uebertragen eines akkus in einen node realisiert ist syncronized da theoretisch von beiden seiten gleichzeitig ge-changed werden koennte.

\end{itemize}

\newpage
% TODO hier pdf include


\end{document}