\documentclass[12pt]{article} 
\usepackage{german} 
\usepackage[utf8]{inputenc} 
\usepackage{latexsym} 
\usepackage{tabu}
\usepackage{amsfonts} 
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{enumerate}
\usepackage{MnSymbol}
\usepackage[colorlinks=true,urlcolor=blue]{hyperref}
\usepackage{listings}
\usepackage{graphicx}
\pagestyle{plain}

% Formatierung
\topmargin -2cm 
\textheight 24cm
\textwidth 16.0 cm 
\oddsidemargin -0.1cm

\setlength{\parindent}{0pt}  % !!!!!!! Hier werden leerzeilen erlaubt ohne dass Latex automatisch einrueckt! !!!!!!! %

% Code-Highlighting 
\lstset{language=Java, breaklines=true, showstringspaces=false}
%\begin{lstlisting}
%    	Hier w체rde der Java-Code hinkommen und entsprechend die Syntax markiert. Selbst einr체cken.
%\end{lstlisting}
%ODER:
% \lstinputlisting[language=Java]{name.java}

\begin{document}

% Titel
%\title{\textsc{Hacking}\\ \textsc{Abgabe 0}\\{ \normalsize Gruppe X \hfill Daniel Sch채fer (2549458)\\ \hfill Anderer}}
%\maketitle  

% alternativer Titel
\noindent
{\Large \textbf{Nebenlaeufige Programmierung}} \hfill Daniel Sch채fer (2549458) \\
{\Large \textbf{Meilenstein 1}} \hfill Christian Bohnenberger (2548364)
\\
{\textbf{16.07.2015}}
\\

\section{Einfuehrung}

Nach anschauen des Codes ist uns klar geworden, dass es auf jeden Fall wichtig sein wird die Rate fuer jeden ''Node'' zu speichern um das staendige Iterieren ueber guards in getRateForTarget zu vermeiden.\\
Wir werden eine Node Klasse anlegen, die einen einzelnen Punkt implementiert. Dieser kennt seine x und y Koordinate als int als auch seine Rate in die Richtungen oben, rechts, unten und links. Ebenfalls wichtig wird der double-Wert value der den momentanen Wert des Knotens enthaelt. Ausserdem einen Akku fuer den Knoten links, rechts oben und unten nebendran hier speichern wir Uebertraege in die entsprechenden Richtungen zwischen. Die ganze Klasse wird als Monitor implementiert um Data Races zu vermeiden. \\
Eine komplette Spalte betrachten wir als Thread und in der Berechnung eines Iterationsschrittes des Osmozeprozesses werden wir zuerst fuer jeden Thread, also jede Spalte die Akkumulatoren nach oben, unten, rechts und links anhand der gespeicherten rates berechnen. Dies wird ueber eine Iterativen Funktionsaufruf der nacheinander die calculate() Funktion auf den Knoten der spalte aufruft uebernommen. Anschliessend rufen wir auf jedem knoten die Funktion flow() auf. Diese fasst die Akkumulatoren nach links und rechts NICHT an, uebertragt jedoch die Uebertraege nach oben und unten in die entsprechenden Knoten oben- bzw. untendrunter und addiert die Akkumulatoren auf deren momentanen wert. Wir benoetigen nur fuer die funktion communicate() spaeter syncronized da nur hier verschiedene Threads kommunizieren. Die Funktion wird nach x Iterationsschritten (x ist vom Benutzer setzbar und bestimmt die Genauigkeit unserer Berechnung) aufgerufen und sorgt dafuer dass die Uebertraege nach links und rechts ueber die spalten hinaus an die korrespondierenden Nachbarn verteilt werden. Es wird also eine Barrier geben die nach X schritten die Iteration unserer calculate() und flow() Funktion fuer jeden threat anhaelt um einen korrekten Aufruf von communicate() zu ermoeglichen.\\
Zu den Datentypen: Die Spalten werden wir als ArrayListe von Nodes implementieren um Zugriffe mit get auf bestimmte Positionen als auch angenehmes iterieren zu ermoeglichen.\\
Ebenfalls sehr relevant zum Sparen von Speicher ist die Tatsache, dass wir zu beginn nur die Knoten erzeugen die eine Value enthalten. Beim Erzeugen von Knoten werden alle ihre Werte (also auch die rate nach oben, unten usw.) berechnet. Wir haben uns fuer den Moment gegen das loeschen von Knoten entschieden die ihre value 'nullen', da wir vermeiden wollen Knoten staendig erneut erzeugen zu muessen, da dies doch relativ aufwendig ist aufgrund der Iteration ueber guards um die rates zu speichern. Wir werden hier ggf. anpassungen nach fertigstellung unseres Projektes vornehmen abhaenig davon wie sich die Laufzeit verhaellt. Zum ersparen zusaetzlicher laufzeit ist es wichtig dass wir bei der funktion communicate() ZUERST ueberpruefen ob ueberhaupt ein Uebertrag in Knoten (x,y) existiert bevor wir auf dessen Existenz ueberpruefen, da wir ihn nur erzeugen moechten (angenommen er waere noch nicht erzeugt) falls ein Akkumulator auf seinen Wert addiert werden wuerde.\\
Unsere Barrier implementieren wir in der Klasse Column die Runnable implementiert, mit einer Bedingung in der run Funktion in der etwas wie \verb+while (count%x != 0)+ uberprueft wird. Jede Column enthaellt den int count der die Nummer des Momentanen Durchlaufs enthaelt als auch die Arrayliste mit den Nodes dieser spalte. Ebenfalls enthalten sind die Columns left und right als Referenzen auf diese Spalten um nachher den Datenaustausch von commmunicate() einfacher zu realisieren. Die Spalten rufen also communicate() auf allen Knoten ihrer Spalte auf. Communicate() enthaelt in den Argumenten Referenzen auf die Nodes mit denen dieser Node 'communicated', also seine linken und rechten Nachbarn. Ebenfalls klar ist, dass man hier auf null Faelle an Raendern und noch nicht existierenden Nodes achten muss (wichtig natuerlich Unterscheidung zwischen Rand und noch nicht erzeugtem Node!). Die einzelnen Spalten sind in der Klasse Picture enthalten, die das komplette Osmosebild repraesentiert. Das Bild wird unter anderem die Spalten in entsprechender Groesse erstellen und anschliessend die Referenzen der Nachbarspalten fuer jede Spalte setzen.\\
Wir betrachten bei Aufruf von communicate() ebenfalls lokale Konvergenz indem wir die Summe der Akkumulatoren die 'nach links gehen' in einer Spalte addieren und schauen wieviel in der Spalte links daneben 'nach rechts geht'. Wir ueberpruefen also ob Inflow einer Spalte $\approx$ Outflow der Spalte. Bei einer Differenz $< \epsilon$ erkennen wir lokale Konvergenz. Tritt in allen Spalten lokale Konvergenz auf sprechen wir von globaler Konvergenz. Diese muessen wir erkennen, da wir nach Erkennen globaler Konvergenz terminieren. Wir haben uns ausserdem eine zusaetzliche Ueberpruefung fuer Terminung ueberlegt: Nach Erreichen der Barrier 'speichern' wir der Wert jedes Nodes nach Ausfuehren von communicate in dem Feld value\_old der klasse Node. Ab dem zweiten Erreichen der Barrier ueberpruefen wir vor dem Ueberschreiben von value\_old fuer jeden existierenden Node ob $|value-value\_old| < \epsilon$. Um nicht gesetzte value\_old werte zu verhindern setzen wir dieses attribut initial im Konstruktor von Node auf 0.\\
Wichtig ist zu erwaehnen das jede Spalte fuer sich nebenlaeufig rechnet, innerhalb einer Spalte calculate() und flow() jedoch sequentiell berechnet werden. Fuer eine bessere Skalierbarkeit unserer Implementierung halten wir uns die Moeglichkeit offen mehrere Threads auch pro Spalte zu ermoeglichen. Deshalb haben wir uns dafuer entschieden auch changeValue fuer Nodes synchronized zu implementieren.\\\\


Anbei fuegen wir noch ein kleines Klassendiagram an, das wir fuer uns selbst entworfen haben um uebersichtlich zu sehen welche Methoden wir in welcher Klasse implementieren wollten.





% ggf moeglich pro spalte 2 threads zu starten fuer die iteration ueber calculate und flow zu beschleunigen




\end{document}